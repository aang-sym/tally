/* tslint:disable */
/* eslint-disable */
/**
 * Tally API (Bundled)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddWatchlistResponse
 */
export interface AddWatchlistResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AddWatchlistResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {AddWatchlistResponseData}
     * @memberof AddWatchlistResponse
     */
    'data'?: AddWatchlistResponseData;
}
/**
 * 
 * @export
 * @interface AddWatchlistResponseData
 */
export interface AddWatchlistResponseData {
    /**
     * 
     * @type {UserShow}
     * @memberof AddWatchlistResponseData
     */
    'userShow'?: UserShow;
    /**
     * 
     * @type {ShowSummary}
     * @memberof AddWatchlistResponseData
     */
    'show'?: ShowSummary;
    /**
     * 
     * @type {Array<AddWatchlistResponseDataAvailabilityInner>}
     * @memberof AddWatchlistResponseData
     */
    'availability'?: Array<AddWatchlistResponseDataAvailabilityInner>;
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AddWatchlistResponseDataAvailabilityInner
 */
export interface AddWatchlistResponseDataAvailabilityInner {
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'country_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'availability_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'price_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'price_currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddWatchlistResponseDataAvailabilityInner
     */
    'deep_link'?: string;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdBufferPutRequest
 */
export interface ApiWatchlistIdBufferPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiWatchlistIdBufferPutRequest
     */
    'bufferDays': number;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdCountryPutRequest
 */
export interface ApiWatchlistIdCountryPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistIdCountryPutRequest
     */
    'countryCode': string | null;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdDelete200Response
 */
export interface ApiWatchlistIdDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWatchlistIdDelete200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {ApiWatchlistIdDelete200ResponseData}
     * @memberof ApiWatchlistIdDelete200Response
     */
    'data'?: ApiWatchlistIdDelete200ResponseData;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdDelete200ResponseData
 */
export interface ApiWatchlistIdDelete200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistIdDelete200ResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdNotesPutRequest
 */
export interface ApiWatchlistIdNotesPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistIdNotesPutRequest
     */
    'notes': string;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdProviderPutRequest
 */
export interface ApiWatchlistIdProviderPutRequest {
    /**
     * 
     * @type {SelectedProvider}
     * @memberof ApiWatchlistIdProviderPutRequest
     */
    'provider': SelectedProvider | null;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdRatingPutRequest
 */
export interface ApiWatchlistIdRatingPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiWatchlistIdRatingPutRequest
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface ApiWatchlistIdStatusPutRequest
 */
export interface ApiWatchlistIdStatusPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistIdStatusPutRequest
     */
    'status': ApiWatchlistIdStatusPutRequestStatusEnum;
}

export const ApiWatchlistIdStatusPutRequestStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching',
    Completed: 'completed',
    Dropped: 'dropped'
} as const;

export type ApiWatchlistIdStatusPutRequestStatusEnum = typeof ApiWatchlistIdStatusPutRequestStatusEnum[keyof typeof ApiWatchlistIdStatusPutRequestStatusEnum];

/**
 * 
 * @export
 * @interface ApiWatchlistPostRequest
 */
export interface ApiWatchlistPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiWatchlistPostRequest
     */
    'tmdbId': number;
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistPostRequest
     */
    'status'?: ApiWatchlistPostRequestStatusEnum;
}

export const ApiWatchlistPostRequestStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching'
} as const;

export type ApiWatchlistPostRequestStatusEnum = typeof ApiWatchlistPostRequestStatusEnum[keyof typeof ApiWatchlistPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface ApiWatchlistTmdbIdProgressPutRequest
 */
export interface ApiWatchlistTmdbIdProgressPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiWatchlistTmdbIdProgressPutRequest
     */
    'seasonNumber': number;
    /**
     * 
     * @type {number}
     * @memberof ApiWatchlistTmdbIdProgressPutRequest
     */
    'episodeNumber': number;
    /**
     * 
     * @type {string}
     * @memberof ApiWatchlistTmdbIdProgressPutRequest
     */
    'status': ApiWatchlistTmdbIdProgressPutRequestStatusEnum;
}

export const ApiWatchlistTmdbIdProgressPutRequestStatusEnum = {
    Watched: 'watched',
    Unwatched: 'unwatched',
    Watching: 'watching'
} as const;

export type ApiWatchlistTmdbIdProgressPutRequestStatusEnum = typeof ApiWatchlistTmdbIdProgressPutRequestStatusEnum[keyof typeof ApiWatchlistTmdbIdProgressPutRequestStatusEnum];

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'details'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
    /**
     * 
     * @type {UserProfile}
     * @memberof LoginResponse
     */
    'user'?: UserProfile;
}
/**
 * 
 * @export
 * @interface PopularService
 */
export interface PopularService {
    /**
     * 
     * @type {string}
     * @memberof PopularService
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PopularService
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PopularService
     */
    'logo_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PopularService
     */
    'homepage'?: string;
    /**
     * 
     * @type {number}
     * @memberof PopularService
     */
    'subscriber_count'?: number;
}
/**
 * 
 * @export
 * @interface PopularServicesResponse
 */
export interface PopularServicesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PopularServicesResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {PopularServicesResponseData}
     * @memberof PopularServicesResponse
     */
    'data'?: PopularServicesResponseData;
}
/**
 * 
 * @export
 * @interface PopularServicesResponseData
 */
export interface PopularServicesResponseData {
    /**
     * 
     * @type {Array<PopularService>}
     * @memberof PopularServicesResponseData
     */
    'services'?: Array<PopularService>;
    /**
     * 
     * @type {number}
     * @memberof PopularServicesResponseData
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PriceTier
 */
export interface PriceTier {
    /**
     * 
     * @type {string}
     * @memberof PriceTier
     */
    'tier'?: string;
    /**
     * 
     * @type {number}
     * @memberof PriceTier
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PriceTier
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceTier
     */
    'billing_frequency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PriceTier
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PriceTier
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceTier
     */
    'provider_name'?: string;
}
/**
 * 
 * @export
 * @interface ProgressUpdateResponse
 */
export interface ProgressUpdateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ProgressUpdateResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ProgressUpdateResponseData}
     * @memberof ProgressUpdateResponse
     */
    'data'?: ProgressUpdateResponseData;
}
/**
 * 
 * @export
 * @interface ProgressUpdateResponseData
 */
export interface ProgressUpdateResponseData {
    /**
     * 
     * @type {number}
     * @memberof ProgressUpdateResponseData
     */
    'updatedCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressUpdateResponseData
     */
    'totalRequested'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProgressUpdateResponseData
     */
    'status'?: ProgressUpdateResponseDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProgressUpdateResponseData
     */
    'message'?: string;
}

export const ProgressUpdateResponseDataStatusEnum = {
    Watched: 'watched',
    Unwatched: 'unwatched',
    Watching: 'watching'
} as const;

export type ProgressUpdateResponseDataStatusEnum = typeof ProgressUpdateResponseDataStatusEnum[keyof typeof ProgressUpdateResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface RateShowResponse
 */
export interface RateShowResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RateShowResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {RateShowResponseData}
     * @memberof RateShowResponse
     */
    'data'?: RateShowResponseData;
}
/**
 * 
 * @export
 * @interface RateShowResponseData
 */
export interface RateShowResponseData {
    /**
     * 
     * @type {number}
     * @memberof RateShowResponseData
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof RateShowResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RegionsResponse
 */
export interface RegionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RegionsResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {RegionsResponseData}
     * @memberof RegionsResponse
     */
    'data'?: RegionsResponseData;
}
/**
 * 
 * @export
 * @interface RegionsResponseData
 */
export interface RegionsResponseData {
    /**
     * 
     * @type {Array<Region>}
     * @memberof RegionsResponseData
     */
    'regions'?: Array<Region>;
    /**
     * 
     * @type {number}
     * @memberof RegionsResponseData
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SchemasPriceTier
 */
export interface SchemasPriceTier {
    /**
     * 
     * @type {string}
     * @memberof SchemasPriceTier
     */
    'tier'?: string;
    /**
     * 
     * @type {number}
     * @memberof SchemasPriceTier
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchemasPriceTier
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchemasPriceTier
     */
    'billing_frequency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SchemasPriceTier
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SchemasPriceTier
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchemasPriceTier
     */
    'provider_name'?: string;
}
/**
 * 
 * @export
 * @interface SelectedProvider
 */
export interface SelectedProvider {
    /**
     * TMDB provider id
     * @type {number}
     * @memberof SelectedProvider
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SelectedProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SelectedProvider
     */
    'logo_path': string;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Service
     */
    'tmdb_provider_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'logo_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'homepage'?: string;
    /**
     * 
     * @type {Array<SchemasPriceTier>}
     * @memberof Service
     */
    'prices'?: Array<SchemasPriceTier>;
    /**
     * 
     * @type {SchemasPriceTier}
     * @memberof Service
     */
    'default_price'?: SchemasPriceTier;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ServiceResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ServiceResponseData}
     * @memberof ServiceResponse
     */
    'data'?: ServiceResponseData;
}
/**
 * 
 * @export
 * @interface ServiceResponseData
 */
export interface ServiceResponseData {
    /**
     * 
     * @type {ServiceResponseDataService}
     * @memberof ServiceResponseData
     */
    'service'?: ServiceResponseDataService;
}
/**
 * 
 * @export
 * @interface ServiceResponseDataService
 */
export interface ServiceResponseDataService {
    /**
     * 
     * @type {string}
     * @memberof ServiceResponseDataService
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponseDataService
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponseDataService
     */
    'logo_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponseDataService
     */
    'homepage'?: string;
}
/**
 * 
 * @export
 * @interface ServicesResponse
 */
export interface ServicesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ServicesResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ServicesResponseData}
     * @memberof ServicesResponse
     */
    'data'?: ServicesResponseData;
}
/**
 * 
 * @export
 * @interface ServicesResponseData
 */
export interface ServicesResponseData {
    /**
     * 
     * @type {Array<Service>}
     * @memberof ServicesResponseData
     */
    'services'?: Array<Service>;
    /**
     * 
     * @type {number}
     * @memberof ServicesResponseData
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface ShowProgressDetailResponse
 */
export interface ShowProgressDetailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ShowProgressDetailResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ShowProgressDetailResponseData}
     * @memberof ShowProgressDetailResponse
     */
    'data'?: ShowProgressDetailResponseData;
}
/**
 * 
 * @export
 * @interface ShowProgressDetailResponseData
 */
export interface ShowProgressDetailResponseData {
    /**
     * 
     * @type {ShowSummary}
     * @memberof ShowProgressDetailResponseData
     */
    'show'?: ShowSummary;
    /**
     * 
     * @type {Array<ShowProgressDetailResponseDataSeasonsInner>}
     * @memberof ShowProgressDetailResponseData
     */
    'seasons'?: Array<ShowProgressDetailResponseDataSeasonsInner>;
    /**
     * 
     * @type {object}
     * @memberof ShowProgressDetailResponseData
     */
    'progress'?: object;
    /**
     * 
     * @type {number}
     * @memberof ShowProgressDetailResponseData
     */
    'totalEpisodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShowProgressDetailResponseData
     */
    'watchedEpisodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShowProgressDetailResponseData
     */
    'completionPercentage'?: number;
}
/**
 * 
 * @export
 * @interface ShowProgressDetailResponseDataSeasonsInner
 */
export interface ShowProgressDetailResponseDataSeasonsInner {
    /**
     * 
     * @type {number}
     * @memberof ShowProgressDetailResponseDataSeasonsInner
     */
    'season_number'?: number;
    /**
     * 
     * @type {Array<ShowProgressDetailResponseDataSeasonsInnerEpisodesInner>}
     * @memberof ShowProgressDetailResponseDataSeasonsInner
     */
    'episodes'?: Array<ShowProgressDetailResponseDataSeasonsInnerEpisodesInner>;
}
/**
 * 
 * @export
 * @interface ShowProgressDetailResponseDataSeasonsInnerEpisodesInner
 */
export interface ShowProgressDetailResponseDataSeasonsInnerEpisodesInner {
    /**
     * 
     * @type {string}
     * @memberof ShowProgressDetailResponseDataSeasonsInnerEpisodesInner
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShowProgressDetailResponseDataSeasonsInnerEpisodesInner
     */
    'episode_number'?: number;
}
/**
 * 
 * @export
 * @interface ShowProgressMapResponse
 */
export interface ShowProgressMapResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ShowProgressMapResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {ShowProgressMapResponseData}
     * @memberof ShowProgressMapResponse
     */
    'data'?: ShowProgressMapResponseData;
}
/**
 * 
 * @export
 * @interface ShowProgressMapResponseData
 */
export interface ShowProgressMapResponseData {
    /**
     * 
     * @type {{ [key: string]: Array<ShowProgressMapResponseDataSeasonsValueInner>; }}
     * @memberof ShowProgressMapResponseData
     */
    'seasons'?: { [key: string]: Array<ShowProgressMapResponseDataSeasonsValueInner>; };
}
/**
 * 
 * @export
 * @interface ShowProgressMapResponseDataSeasonsValueInner
 */
export interface ShowProgressMapResponseDataSeasonsValueInner {
    /**
     * 
     * @type {number}
     * @memberof ShowProgressMapResponseDataSeasonsValueInner
     */
    'episodeNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShowProgressMapResponseDataSeasonsValueInner
     */
    'status'?: string;
}
/**
 * Normalized show object from DB + poster URL normalization
 * @export
 * @interface ShowSummary
 */
export interface ShowSummary {
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShowSummary
     */
    'tmdb_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'overview'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'poster_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'first_air_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'last_air_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowSummary
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShowSummary
     */
    'total_seasons'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShowSummary
     */
    'total_episodes'?: number;
}
/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface StreamingServiceSummary
 */
export interface StreamingServiceSummary {
    /**
     * 
     * @type {string}
     * @memberof StreamingServiceSummary
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StreamingServiceSummary
     */
    'tmdb_provider_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StreamingServiceSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamingServiceSummary
     */
    'logo_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamingServiceSummary
     */
    'homepage'?: string;
    /**
     * 
     * @type {Array<PriceTier>}
     * @memberof StreamingServiceSummary
     */
    'prices'?: Array<PriceTier>;
    /**
     * 
     * @type {PriceTier}
     * @memberof StreamingServiceSummary
     */
    'default_price'?: PriceTier;
}
/**
 * 
 * @export
 * @interface SubscriptionCreateRequest
 */
export interface SubscriptionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateRequest
     */
    'service_id': string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionCreateRequest
     */
    'monthly_cost': number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionCreateRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateRequest
     */
    'tier'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionResponse
 */
export interface SubscriptionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserSubscription}
     * @memberof SubscriptionResponse
     */
    'data'?: UserSubscription;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdateRequest
 */
export interface SubscriptionUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUpdateRequest
     */
    'monthly_cost'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionUpdateRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdateRequest
     */
    'tier'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsEnvelope
 */
export interface SubscriptionsEnvelope {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionsEnvelope
     */
    'success'?: boolean;
    /**
     * 
     * @type {SubscriptionsEnvelopeData}
     * @memberof SubscriptionsEnvelope
     */
    'data'?: SubscriptionsEnvelopeData;
}
/**
 * 
 * @export
 * @interface SubscriptionsEnvelopeData
 */
export interface SubscriptionsEnvelopeData {
    /**
     * 
     * @type {Array<UserSubscription>}
     * @memberof SubscriptionsEnvelopeData
     */
    'subscriptions'?: Array<UserSubscription>;
}
/**
 * 
 * @export
 * @interface SubscriptionsResponse
 */
export interface SubscriptionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionsResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {SubscriptionsEnvelopeData}
     * @memberof SubscriptionsResponse
     */
    'data'?: SubscriptionsEnvelopeData;
}
/**
 * 
 * @export
 * @interface UpdateBufferResponse
 */
export interface UpdateBufferResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBufferResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UpdateBufferResponseData}
     * @memberof UpdateBufferResponse
     */
    'data'?: UpdateBufferResponseData;
}
/**
 * 
 * @export
 * @interface UpdateBufferResponseData
 */
export interface UpdateBufferResponseData {
    /**
     * 
     * @type {number}
     * @memberof UpdateBufferResponseData
     */
    'bufferDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateBufferResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCountryResponse
 */
export interface UpdateCountryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCountryResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UpdateCountryResponseData}
     * @memberof UpdateCountryResponse
     */
    'data'?: UpdateCountryResponseData;
}
/**
 * 
 * @export
 * @interface UpdateCountryResponseData
 */
export interface UpdateCountryResponseData {
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryResponseData
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateNotesResponse
 */
export interface UpdateNotesResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotesResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UpdateNotesResponseData}
     * @memberof UpdateNotesResponse
     */
    'data'?: UpdateNotesResponseData;
}
/**
 * 
 * @export
 * @interface UpdateNotesResponseData
 */
export interface UpdateNotesResponseData {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotesResponseData
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotesResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProviderResponse
 */
export interface UpdateProviderResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateProviderResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UpdateProviderResponseData}
     * @memberof UpdateProviderResponse
     */
    'data'?: UpdateProviderResponseData;
}
/**
 * 
 * @export
 * @interface UpdateProviderResponseData
 */
export interface UpdateProviderResponseData {
    /**
     * 
     * @type {SelectedProvider}
     * @memberof UpdateProviderResponseData
     */
    'provider'?: SelectedProvider | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProviderResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'country_code'?: string;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserProfileResponse
     */
    'data'?: UserProfile;
}
/**
 * 
 * @export
 * @interface UserShow
 */
export interface UserShow {
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'show_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'status'?: UserShowStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'added_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'started_watching_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'completed_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'last_episode_watched_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserShow
     */
    'show_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserShow
     */
    'buffer_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'selected_service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserShow
     */
    'country_code'?: string;
}

export const UserShowStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching',
    Completed: 'completed',
    Dropped: 'dropped'
} as const;

export type UserShowStatusEnum = typeof UserShowStatusEnum[keyof typeof UserShowStatusEnum];

/**
 * 
 * @export
 * @interface UserShowStatusResponse
 */
export interface UserShowStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserShowStatusResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {WatchlistSearchAndAdd201ResponseData}
     * @memberof UserShowStatusResponse
     */
    'data'?: WatchlistSearchAndAdd201ResponseData;
}
/**
 * 
 * @export
 * @interface UserSubscription
 */
export interface UserSubscription {
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'service_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSubscription
     */
    'monthly_cost'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSubscription
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'started_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'ended_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscription
     */
    'tier'?: string;
    /**
     * 
     * @type {StreamingServiceSummary}
     * @memberof UserSubscription
     */
    'service'?: StreamingServiceSummary;
}
/**
 * 
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'country_code'?: string;
}
/**
 * 
 * @export
 * @interface UsersList200Response
 */
export interface UsersList200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UsersList200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {UsersList200ResponseData}
     * @memberof UsersList200Response
     */
    'data'?: UsersList200ResponseData;
}
/**
 * 
 * @export
 * @interface UsersList200ResponseData
 */
export interface UsersList200ResponseData {
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof UsersList200ResponseData
     */
    'users'?: Array<UserProfile>;
}
/**
 * 
 * @export
 * @interface WatchingListResponse
 */
export interface WatchingListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WatchingListResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {WatchingListResponseData}
     * @memberof WatchingListResponse
     */
    'data'?: WatchingListResponseData;
}
/**
 * 
 * @export
 * @interface WatchingListResponseData
 */
export interface WatchingListResponseData {
    /**
     * 
     * @type {Array<WatchingListResponseDataShowsInner>}
     * @memberof WatchingListResponseData
     */
    'shows'?: Array<WatchingListResponseDataShowsInner>;
    /**
     * 
     * @type {number}
     * @memberof WatchingListResponseData
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface WatchingListResponseDataShowsInner
 */
export interface WatchingListResponseDataShowsInner {
    /**
     * 
     * @type {string}
     * @memberof WatchingListResponseDataShowsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchingListResponseDataShowsInner
     */
    'status'?: WatchingListResponseDataShowsInnerStatusEnum;
    /**
     * 
     * @type {ShowSummary}
     * @memberof WatchingListResponseDataShowsInner
     */
    'show'?: ShowSummary;
    /**
     * 
     * @type {SelectedProvider}
     * @memberof WatchingListResponseDataShowsInner
     */
    'streaming_provider'?: SelectedProvider;
}

export const WatchingListResponseDataShowsInnerStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching',
    Completed: 'completed',
    Dropped: 'dropped'
} as const;

export type WatchingListResponseDataShowsInnerStatusEnum = typeof WatchingListResponseDataShowsInnerStatusEnum[keyof typeof WatchingListResponseDataShowsInnerStatusEnum];

/**
 * 
 * @export
 * @interface WatchlistListResponse
 */
export interface WatchlistListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WatchlistListResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {WatchlistListResponseData}
     * @memberof WatchlistListResponse
     */
    'data'?: WatchlistListResponseData;
}
/**
 * 
 * @export
 * @interface WatchlistListResponseData
 */
export interface WatchlistListResponseData {
    /**
     * 
     * @type {Array<WatchlistRow>}
     * @memberof WatchlistListResponseData
     */
    'shows'?: Array<WatchlistRow>;
    /**
     * 
     * @type {number}
     * @memberof WatchlistListResponseData
     */
    'totalCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof WatchlistListResponseData
     */
    'statusFilter'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistRow
 */
export interface WatchlistRow {
    /**
     * 
     * @type {string}
     * @memberof WatchlistRow
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistRow
     */
    'status'?: WatchlistRowStatusEnum;
    /**
     * 
     * @type {ShowSummary}
     * @memberof WatchlistRow
     */
    'show'?: ShowSummary;
    /**
     * 
     * @type {SelectedProvider}
     * @memberof WatchlistRow
     */
    'streaming_provider'?: SelectedProvider | null;
}

export const WatchlistRowStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching',
    Completed: 'completed',
    Dropped: 'dropped'
} as const;

export type WatchlistRowStatusEnum = typeof WatchlistRowStatusEnum[keyof typeof WatchlistRowStatusEnum];

/**
 * 
 * @export
 * @interface WatchlistSearchAndAdd201Response
 */
export interface WatchlistSearchAndAdd201Response {
    /**
     * 
     * @type {boolean}
     * @memberof WatchlistSearchAndAdd201Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {WatchlistSearchAndAdd201ResponseData}
     * @memberof WatchlistSearchAndAdd201Response
     */
    'data'?: WatchlistSearchAndAdd201ResponseData;
}
/**
 * 
 * @export
 * @interface WatchlistSearchAndAdd201ResponseData
 */
export interface WatchlistSearchAndAdd201ResponseData {
    /**
     * 
     * @type {UserShow}
     * @memberof WatchlistSearchAndAdd201ResponseData
     */
    'userShow'?: UserShow;
    /**
     * 
     * @type {string}
     * @memberof WatchlistSearchAndAdd201ResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistSearchAndAddRequest
 */
export interface WatchlistSearchAndAddRequest {
    /**
     * 
     * @type {string}
     * @memberof WatchlistSearchAndAddRequest
     */
    'query'?: string;
    /**
     * 
     * @type {number}
     * @memberof WatchlistSearchAndAddRequest
     */
    'tmdbId'?: number;
    /**
     * 
     * @type {string}
     * @memberof WatchlistSearchAndAddRequest
     */
    'status'?: WatchlistSearchAndAddRequestStatusEnum;
}

export const WatchlistSearchAndAddRequestStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching'
} as const;

export type WatchlistSearchAndAddRequestStatusEnum = typeof WatchlistSearchAndAddRequestStatusEnum[keyof typeof WatchlistSearchAndAddRequestStatusEnum];
/**
 * 
 * @export
 * @interface WatchlistStatsResponse
 */
export interface WatchlistStatsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WatchlistStatsResponse
     */
    'success'?: boolean;
    /**
     * Implementation-defined stats from WatchlistService.getUserWatchlistStats
     * @type {object}
     * @memberof WatchlistStatsResponse
     */
    'data'?: object;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns streaming services with price tiers for a given country. If `country` is omitted, the server falls back to the authenticated user\'s `users.country_code`, then \'US\'. 
         * @summary List streaming services
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesGet: async (country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/streaming-services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a streaming service by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStreamingServicesIdGet', 'id', id)
            const localVarPath = `/api/streaming-services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List most popular services by active subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesPopularGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/streaming-services/popular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List common regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesRegionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/streaming-services/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user\'s active/inactive subscriptions. Prices/tiers in the embedded service object are filtered by `country`. If `country` is omitted server-side may fall back to `users.country_code`, then \'US\'. 
         * @summary List a user\'s subscriptions
         * @param {string} id User UUID
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsGet: async (id: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsGet', 'id', id)
            const localVarPath = `/api/users/{id}/subscriptions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new subscription for the user; if one already exists for the service, updates it. `tier` is optional; when provided, it is stored alongside the subscription. 
         * @summary Add (or upsert) a subscription
         * @param {string} id User UUID
         * @param {SubscriptionCreateRequest} subscriptionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsPost: async (id: string, subscriptionCreateRequest: SubscriptionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsPost', 'id', id)
            // verify required parameter 'subscriptionCreateRequest' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsPost', 'subscriptionCreateRequest', subscriptionCreateRequest)
            const localVarPath = `/api/users/{id}/subscriptions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes or marks the subscription inactive (implementation-defined). Client should treat as removed. 
         * @summary Remove (deactivate or delete) a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsSubscriptionIdDelete: async (id: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsSubscriptionIdDelete', 'id', id)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsSubscriptionIdDelete', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/users/{id}/subscriptions/{subscriptionId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partial update; any of `monthly_cost`, `is_active`, or `tier` may be provided. Supports **tier-only** updates for quick UI changes. 
         * @summary Update a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {SubscriptionUpdateRequest} subscriptionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsSubscriptionIdPut: async (id: string, subscriptionId: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsSubscriptionIdPut', 'id', id)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsSubscriptionIdPut', 'subscriptionId', subscriptionId)
            // verify required parameter 'subscriptionUpdateRequest' is not null or undefined
            assertParamExists('apiUsersIdSubscriptionsSubscriptionIdPut', 'subscriptionUpdateRequest', subscriptionUpdateRequest)
            const localVarPath = `/api/users/{id}/subscriptions/{subscriptionId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user\'s watchlist with normalized show details and selected streaming provider. Optional `status` query filters by watchlist status. 
         * @summary Get user\'s watchlist
         * @param {ApiWatchlistGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistGet: async (status?: ApiWatchlistGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watchlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update buffer days for a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdBufferPutRequest} apiWatchlistIdBufferPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdBufferPut: async (id: string, apiWatchlistIdBufferPutRequest: ApiWatchlistIdBufferPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdBufferPut', 'id', id)
            // verify required parameter 'apiWatchlistIdBufferPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdBufferPut', 'apiWatchlistIdBufferPutRequest', apiWatchlistIdBufferPutRequest)
            const localVarPath = `/api/watchlist/{id}/buffer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdBufferPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a per-show `countryCode` (e.g., AU) or clear it with `null`. 
         * @summary Update per-show country override
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdCountryPutRequest} apiWatchlistIdCountryPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdCountryPut: async (id: string, apiWatchlistIdCountryPutRequest: ApiWatchlistIdCountryPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdCountryPut', 'id', id)
            // verify required parameter 'apiWatchlistIdCountryPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdCountryPut', 'apiWatchlistIdCountryPutRequest', apiWatchlistIdCountryPutRequest)
            const localVarPath = `/api/watchlist/{id}/country`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdCountryPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove show from watchlist
         * @param {string} id User show id (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdDelete', 'id', id)
            const localVarPath = `/api/watchlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update show notes
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdNotesPutRequest} apiWatchlistIdNotesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdNotesPut: async (id: string, apiWatchlistIdNotesPutRequest: ApiWatchlistIdNotesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdNotesPut', 'id', id)
            // verify required parameter 'apiWatchlistIdNotesPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdNotesPut', 'apiWatchlistIdNotesPutRequest', apiWatchlistIdNotesPutRequest)
            const localVarPath = `/api/watchlist/{id}/notes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdNotesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set or clear (`null`) the provider. Expects `{ id, name, logo_path }` when not null. 
         * @summary Update selected streaming provider for the user\'s show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdProviderPutRequest} apiWatchlistIdProviderPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdProviderPut: async (id: string, apiWatchlistIdProviderPutRequest: ApiWatchlistIdProviderPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdProviderPut', 'id', id)
            // verify required parameter 'apiWatchlistIdProviderPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdProviderPut', 'apiWatchlistIdProviderPutRequest', apiWatchlistIdProviderPutRequest)
            const localVarPath = `/api/watchlist/{id}/provider`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdProviderPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rate a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdRatingPutRequest} apiWatchlistIdRatingPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdRatingPut: async (id: string, apiWatchlistIdRatingPutRequest: ApiWatchlistIdRatingPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdRatingPut', 'id', id)
            // verify required parameter 'apiWatchlistIdRatingPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdRatingPut', 'apiWatchlistIdRatingPutRequest', apiWatchlistIdRatingPutRequest)
            const localVarPath = `/api/watchlist/{id}/rating`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdRatingPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a show\'s status
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdStatusPutRequest} apiWatchlistIdStatusPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdStatusPut: async (id: string, apiWatchlistIdStatusPutRequest: ApiWatchlistIdStatusPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWatchlistIdStatusPut', 'id', id)
            // verify required parameter 'apiWatchlistIdStatusPutRequest' is not null or undefined
            assertParamExists('apiWatchlistIdStatusPut', 'apiWatchlistIdStatusPutRequest', apiWatchlistIdStatusPutRequest)
            const localVarPath = `/api/watchlist/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistIdStatusPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a show (by TMDB ID) to the user\'s watchlist; status defaults to `watchlist`. 
         * @summary Add a show to the user\'s watchlist
         * @param {ApiWatchlistPostRequest} apiWatchlistPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistPost: async (apiWatchlistPostRequest: ApiWatchlistPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiWatchlistPostRequest' is not null or undefined
            assertParamExists('apiWatchlistPost', 'apiWatchlistPostRequest', apiWatchlistPostRequest)
            const localVarPath = `/api/watchlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s watchlist statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watchlist/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s episode progress for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistTmdbIdProgressGet: async (tmdbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmdbId' is not null or undefined
            assertParamExists('apiWatchlistTmdbIdProgressGet', 'tmdbId', tmdbId)
            const localVarPath = `/api/watchlist/{tmdbId}/progress`
                .replace(`{${"tmdbId"}}`, encodeURIComponent(String(tmdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets progress for all episodes up to (and including) the specified episode. 
         * @summary Set episode progress up to an episode (inclusive) for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {ApiWatchlistTmdbIdProgressPutRequest} apiWatchlistTmdbIdProgressPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistTmdbIdProgressPut: async (tmdbId: number, apiWatchlistTmdbIdProgressPutRequest: ApiWatchlistTmdbIdProgressPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmdbId' is not null or undefined
            assertParamExists('apiWatchlistTmdbIdProgressPut', 'tmdbId', tmdbId)
            // verify required parameter 'apiWatchlistTmdbIdProgressPutRequest' is not null or undefined
            assertParamExists('apiWatchlistTmdbIdProgressPut', 'apiWatchlistTmdbIdProgressPutRequest', apiWatchlistTmdbIdProgressPutRequest)
            const localVarPath = `/api/watchlist/{tmdbId}/progress`
                .replace(`{${"tmdbId"}}`, encodeURIComponent(String(tmdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWatchlistTmdbIdProgressPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List currently watching shows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistWatchingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watchlist/watching`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get detailed progress for a specific show (by internal show id)
         * @param {string} showId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistWatchingShowIdGet: async (showId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'showId' is not null or undefined
            assertParamExists('apiWatchlistWatchingShowIdGet', 'showId', showId)
            const localVarPath = `/api/watchlist/watching/{showId}`
                .replace(`{${"showId"}}`, encodeURIComponent(String(showId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search TMDB and add a show in one request
         * @param {WatchlistSearchAndAddRequest | null} watchlistSearchAndAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchlistSearchAndAdd: async (watchlistSearchAndAddRequest: WatchlistSearchAndAddRequest | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watchlistSearchAndAddRequest' is not null or undefined
            assertParamExists('watchlistSearchAndAdd', 'watchlistSearchAndAddRequest', watchlistSearchAndAddRequest)
            const localVarPath = `/api/watchlist/search-and-add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistSearchAndAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns streaming services with price tiers for a given country. If `country` is omitted, the server falls back to the authenticated user\'s `users.country_code`, then \'US\'. 
         * @summary List streaming services
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStreamingServicesGet(country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStreamingServicesGet(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiStreamingServicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a streaming service by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStreamingServicesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStreamingServicesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiStreamingServicesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List most popular services by active subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStreamingServicesPopularGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PopularServicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStreamingServicesPopularGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiStreamingServicesPopularGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List common regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStreamingServicesRegionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStreamingServicesRegionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiStreamingServicesRegionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the user\'s active/inactive subscriptions. Prices/tiers in the embedded service object are filtered by `country`. If `country` is omitted server-side may fall back to `users.country_code`, then \'US\'. 
         * @summary List a user\'s subscriptions
         * @param {string} id User UUID
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdSubscriptionsGet(id: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdSubscriptionsGet(id, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUsersIdSubscriptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new subscription for the user; if one already exists for the service, updates it. `tier` is optional; when provided, it is stored alongside the subscription. 
         * @summary Add (or upsert) a subscription
         * @param {string} id User UUID
         * @param {SubscriptionCreateRequest} subscriptionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdSubscriptionsPost(id: string, subscriptionCreateRequest: SubscriptionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdSubscriptionsPost(id, subscriptionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUsersIdSubscriptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes or marks the subscription inactive (implementation-defined). Client should treat as removed. 
         * @summary Remove (deactivate or delete) a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdSubscriptionsSubscriptionIdDelete(id: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdSubscriptionsSubscriptionIdDelete(id, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUsersIdSubscriptionsSubscriptionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partial update; any of `monthly_cost`, `is_active`, or `tier` may be provided. Supports **tier-only** updates for quick UI changes. 
         * @summary Update a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {SubscriptionUpdateRequest} subscriptionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdSubscriptionsSubscriptionIdPut(id: string, subscriptionId: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdSubscriptionsSubscriptionIdPut(id, subscriptionId, subscriptionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUsersIdSubscriptionsSubscriptionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the user\'s watchlist with normalized show details and selected streaming provider. Optional `status` query filters by watchlist status. 
         * @summary Get user\'s watchlist
         * @param {ApiWatchlistGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistGet(status?: ApiWatchlistGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update buffer days for a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdBufferPutRequest} apiWatchlistIdBufferPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdBufferPut(id: string, apiWatchlistIdBufferPutRequest: ApiWatchlistIdBufferPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateBufferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdBufferPut(id, apiWatchlistIdBufferPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdBufferPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a per-show `countryCode` (e.g., AU) or clear it with `null`. 
         * @summary Update per-show country override
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdCountryPutRequest} apiWatchlistIdCountryPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdCountryPut(id: string, apiWatchlistIdCountryPutRequest: ApiWatchlistIdCountryPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCountryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdCountryPut(id, apiWatchlistIdCountryPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdCountryPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove show from watchlist
         * @param {string} id User show id (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWatchlistIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update show notes
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdNotesPutRequest} apiWatchlistIdNotesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdNotesPut(id: string, apiWatchlistIdNotesPutRequest: ApiWatchlistIdNotesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateNotesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdNotesPut(id, apiWatchlistIdNotesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdNotesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set or clear (`null`) the provider. Expects `{ id, name, logo_path }` when not null. 
         * @summary Update selected streaming provider for the user\'s show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdProviderPutRequest} apiWatchlistIdProviderPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdProviderPut(id: string, apiWatchlistIdProviderPutRequest: ApiWatchlistIdProviderPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdProviderPut(id, apiWatchlistIdProviderPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdProviderPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rate a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdRatingPutRequest} apiWatchlistIdRatingPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdRatingPut(id: string, apiWatchlistIdRatingPutRequest: ApiWatchlistIdRatingPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdRatingPut(id, apiWatchlistIdRatingPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdRatingPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a show\'s status
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdStatusPutRequest} apiWatchlistIdStatusPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistIdStatusPut(id: string, apiWatchlistIdStatusPutRequest: ApiWatchlistIdStatusPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShowStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistIdStatusPut(id, apiWatchlistIdStatusPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistIdStatusPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a show (by TMDB ID) to the user\'s watchlist; status defaults to `watchlist`. 
         * @summary Add a show to the user\'s watchlist
         * @param {ApiWatchlistPostRequest} apiWatchlistPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistPost(apiWatchlistPostRequest: ApiWatchlistPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddWatchlistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistPost(apiWatchlistPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s watchlist statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s episode progress for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistTmdbIdProgressGet(tmdbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowProgressMapResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistTmdbIdProgressGet(tmdbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistTmdbIdProgressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets progress for all episodes up to (and including) the specified episode. 
         * @summary Set episode progress up to an episode (inclusive) for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {ApiWatchlistTmdbIdProgressPutRequest} apiWatchlistTmdbIdProgressPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistTmdbIdProgressPut(tmdbId: number, apiWatchlistTmdbIdProgressPutRequest: ApiWatchlistTmdbIdProgressPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistTmdbIdProgressPut(tmdbId, apiWatchlistTmdbIdProgressPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistTmdbIdProgressPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List currently watching shows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistWatchingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchingListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistWatchingGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistWatchingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get detailed progress for a specific show (by internal show id)
         * @param {string} showId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWatchlistWatchingShowIdGet(showId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowProgressDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWatchlistWatchingShowIdGet(showId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiWatchlistWatchingShowIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search TMDB and add a show in one request
         * @param {WatchlistSearchAndAddRequest | null} watchlistSearchAndAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watchlistSearchAndAdd(watchlistSearchAndAddRequest: WatchlistSearchAndAddRequest | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistSearchAndAdd201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watchlistSearchAndAdd(watchlistSearchAndAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.watchlistSearchAndAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Returns streaming services with price tiers for a given country. If `country` is omitted, the server falls back to the authenticated user\'s `users.country_code`, then \'US\'. 
         * @summary List streaming services
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesGet(country?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServicesResponse> {
            return localVarFp.apiStreamingServicesGet(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a streaming service by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceResponse> {
            return localVarFp.apiStreamingServicesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List most popular services by active subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesPopularGet(options?: RawAxiosRequestConfig): AxiosPromise<PopularServicesResponse> {
            return localVarFp.apiStreamingServicesPopularGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List common regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStreamingServicesRegionsGet(options?: RawAxiosRequestConfig): AxiosPromise<RegionsResponse> {
            return localVarFp.apiStreamingServicesRegionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user\'s active/inactive subscriptions. Prices/tiers in the embedded service object are filtered by `country`. If `country` is omitted server-side may fall back to `users.country_code`, then \'US\'. 
         * @summary List a user\'s subscriptions
         * @param {string} id User UUID
         * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsGet(id: string, country?: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionsResponse> {
            return localVarFp.apiUsersIdSubscriptionsGet(id, country, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new subscription for the user; if one already exists for the service, updates it. `tier` is optional; when provided, it is stored alongside the subscription. 
         * @summary Add (or upsert) a subscription
         * @param {string} id User UUID
         * @param {SubscriptionCreateRequest} subscriptionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsPost(id: string, subscriptionCreateRequest: SubscriptionCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionResponse> {
            return localVarFp.apiUsersIdSubscriptionsPost(id, subscriptionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes or marks the subscription inactive (implementation-defined). Client should treat as removed. 
         * @summary Remove (deactivate or delete) a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsSubscriptionIdDelete(id: string, subscriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersIdSubscriptionsSubscriptionIdDelete(id, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Partial update; any of `monthly_cost`, `is_active`, or `tier` may be provided. Supports **tier-only** updates for quick UI changes. 
         * @summary Update a subscription
         * @param {string} id User UUID
         * @param {string} subscriptionId Subscription UUID
         * @param {SubscriptionUpdateRequest} subscriptionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdSubscriptionsSubscriptionIdPut(id: string, subscriptionId: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionResponse> {
            return localVarFp.apiUsersIdSubscriptionsSubscriptionIdPut(id, subscriptionId, subscriptionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user\'s watchlist with normalized show details and selected streaming provider. Optional `status` query filters by watchlist status. 
         * @summary Get user\'s watchlist
         * @param {ApiWatchlistGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistGet(status?: ApiWatchlistGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistListResponse> {
            return localVarFp.apiWatchlistGet(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update buffer days for a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdBufferPutRequest} apiWatchlistIdBufferPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdBufferPut(id: string, apiWatchlistIdBufferPutRequest: ApiWatchlistIdBufferPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateBufferResponse> {
            return localVarFp.apiWatchlistIdBufferPut(id, apiWatchlistIdBufferPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a per-show `countryCode` (e.g., AU) or clear it with `null`. 
         * @summary Update per-show country override
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdCountryPutRequest} apiWatchlistIdCountryPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdCountryPut(id: string, apiWatchlistIdCountryPutRequest: ApiWatchlistIdCountryPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateCountryResponse> {
            return localVarFp.apiWatchlistIdCountryPut(id, apiWatchlistIdCountryPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove show from watchlist
         * @param {string} id User show id (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiWatchlistIdDelete200Response> {
            return localVarFp.apiWatchlistIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update show notes
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdNotesPutRequest} apiWatchlistIdNotesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdNotesPut(id: string, apiWatchlistIdNotesPutRequest: ApiWatchlistIdNotesPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateNotesResponse> {
            return localVarFp.apiWatchlistIdNotesPut(id, apiWatchlistIdNotesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set or clear (`null`) the provider. Expects `{ id, name, logo_path }` when not null. 
         * @summary Update selected streaming provider for the user\'s show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdProviderPutRequest} apiWatchlistIdProviderPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdProviderPut(id: string, apiWatchlistIdProviderPutRequest: ApiWatchlistIdProviderPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProviderResponse> {
            return localVarFp.apiWatchlistIdProviderPut(id, apiWatchlistIdProviderPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rate a show
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdRatingPutRequest} apiWatchlistIdRatingPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdRatingPut(id: string, apiWatchlistIdRatingPutRequest: ApiWatchlistIdRatingPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<RateShowResponse> {
            return localVarFp.apiWatchlistIdRatingPut(id, apiWatchlistIdRatingPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a show\'s status
         * @param {string} id User show id (UUID)
         * @param {ApiWatchlistIdStatusPutRequest} apiWatchlistIdStatusPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistIdStatusPut(id: string, apiWatchlistIdStatusPutRequest: ApiWatchlistIdStatusPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserShowStatusResponse> {
            return localVarFp.apiWatchlistIdStatusPut(id, apiWatchlistIdStatusPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a show (by TMDB ID) to the user\'s watchlist; status defaults to `watchlist`. 
         * @summary Add a show to the user\'s watchlist
         * @param {ApiWatchlistPostRequest} apiWatchlistPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistPost(apiWatchlistPostRequest: ApiWatchlistPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddWatchlistResponse> {
            return localVarFp.apiWatchlistPost(apiWatchlistPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s watchlist statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<WatchlistStatsResponse> {
            return localVarFp.apiWatchlistStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s episode progress for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistTmdbIdProgressGet(tmdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<ShowProgressMapResponse> {
            return localVarFp.apiWatchlistTmdbIdProgressGet(tmdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets progress for all episodes up to (and including) the specified episode. 
         * @summary Set episode progress up to an episode (inclusive) for a show (by TMDB ID)
         * @param {number} tmdbId 
         * @param {ApiWatchlistTmdbIdProgressPutRequest} apiWatchlistTmdbIdProgressPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistTmdbIdProgressPut(tmdbId: number, apiWatchlistTmdbIdProgressPutRequest: ApiWatchlistTmdbIdProgressPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProgressUpdateResponse> {
            return localVarFp.apiWatchlistTmdbIdProgressPut(tmdbId, apiWatchlistTmdbIdProgressPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List currently watching shows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistWatchingGet(options?: RawAxiosRequestConfig): AxiosPromise<WatchingListResponse> {
            return localVarFp.apiWatchlistWatchingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get detailed progress for a specific show (by internal show id)
         * @param {string} showId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWatchlistWatchingShowIdGet(showId: string, options?: RawAxiosRequestConfig): AxiosPromise<ShowProgressDetailResponse> {
            return localVarFp.apiWatchlistWatchingShowIdGet(showId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search TMDB and add a show in one request
         * @param {WatchlistSearchAndAddRequest | null} watchlistSearchAndAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchlistSearchAndAdd(watchlistSearchAndAddRequest: WatchlistSearchAndAddRequest | null, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistSearchAndAdd201Response> {
            return localVarFp.watchlistSearchAndAdd(watchlistSearchAndAddRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns streaming services with price tiers for a given country. If `country` is omitted, the server falls back to the authenticated user\'s `users.country_code`, then \'US\'. 
     * @summary List streaming services
     * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiStreamingServicesGet(country?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiStreamingServicesGet(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a streaming service by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiStreamingServicesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiStreamingServicesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List most popular services by active subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiStreamingServicesPopularGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiStreamingServicesPopularGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List common regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiStreamingServicesRegionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiStreamingServicesRegionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user\'s active/inactive subscriptions. Prices/tiers in the embedded service object are filtered by `country`. If `country` is omitted server-side may fall back to `users.country_code`, then \'US\'. 
     * @summary List a user\'s subscriptions
     * @param {string} id User UUID
     * @param {string} [country] ISO 3166-1 alpha-2 country code (e.g., AU, US).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdSubscriptionsGet(id: string, country?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUsersIdSubscriptionsGet(id, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new subscription for the user; if one already exists for the service, updates it. `tier` is optional; when provided, it is stored alongside the subscription. 
     * @summary Add (or upsert) a subscription
     * @param {string} id User UUID
     * @param {SubscriptionCreateRequest} subscriptionCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdSubscriptionsPost(id: string, subscriptionCreateRequest: SubscriptionCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUsersIdSubscriptionsPost(id, subscriptionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes or marks the subscription inactive (implementation-defined). Client should treat as removed. 
     * @summary Remove (deactivate or delete) a subscription
     * @param {string} id User UUID
     * @param {string} subscriptionId Subscription UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdSubscriptionsSubscriptionIdDelete(id: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUsersIdSubscriptionsSubscriptionIdDelete(id, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partial update; any of `monthly_cost`, `is_active`, or `tier` may be provided. Supports **tier-only** updates for quick UI changes. 
     * @summary Update a subscription
     * @param {string} id User UUID
     * @param {string} subscriptionId Subscription UUID
     * @param {SubscriptionUpdateRequest} subscriptionUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUsersIdSubscriptionsSubscriptionIdPut(id: string, subscriptionId: string, subscriptionUpdateRequest: SubscriptionUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUsersIdSubscriptionsSubscriptionIdPut(id, subscriptionId, subscriptionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user\'s watchlist with normalized show details and selected streaming provider. Optional `status` query filters by watchlist status. 
     * @summary Get user\'s watchlist
     * @param {ApiWatchlistGetStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistGet(status?: ApiWatchlistGetStatusEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistGet(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update buffer days for a show
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdBufferPutRequest} apiWatchlistIdBufferPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdBufferPut(id: string, apiWatchlistIdBufferPutRequest: ApiWatchlistIdBufferPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdBufferPut(id, apiWatchlistIdBufferPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a per-show `countryCode` (e.g., AU) or clear it with `null`. 
     * @summary Update per-show country override
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdCountryPutRequest} apiWatchlistIdCountryPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdCountryPut(id: string, apiWatchlistIdCountryPutRequest: ApiWatchlistIdCountryPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdCountryPut(id, apiWatchlistIdCountryPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove show from watchlist
     * @param {string} id User show id (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update show notes
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdNotesPutRequest} apiWatchlistIdNotesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdNotesPut(id: string, apiWatchlistIdNotesPutRequest: ApiWatchlistIdNotesPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdNotesPut(id, apiWatchlistIdNotesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set or clear (`null`) the provider. Expects `{ id, name, logo_path }` when not null. 
     * @summary Update selected streaming provider for the user\'s show
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdProviderPutRequest} apiWatchlistIdProviderPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdProviderPut(id: string, apiWatchlistIdProviderPutRequest: ApiWatchlistIdProviderPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdProviderPut(id, apiWatchlistIdProviderPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rate a show
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdRatingPutRequest} apiWatchlistIdRatingPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdRatingPut(id: string, apiWatchlistIdRatingPutRequest: ApiWatchlistIdRatingPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdRatingPut(id, apiWatchlistIdRatingPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a show\'s status
     * @param {string} id User show id (UUID)
     * @param {ApiWatchlistIdStatusPutRequest} apiWatchlistIdStatusPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistIdStatusPut(id: string, apiWatchlistIdStatusPutRequest: ApiWatchlistIdStatusPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistIdStatusPut(id, apiWatchlistIdStatusPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a show (by TMDB ID) to the user\'s watchlist; status defaults to `watchlist`. 
     * @summary Add a show to the user\'s watchlist
     * @param {ApiWatchlistPostRequest} apiWatchlistPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistPost(apiWatchlistPostRequest: ApiWatchlistPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistPost(apiWatchlistPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s watchlist statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistStatsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s episode progress for a show (by TMDB ID)
     * @param {number} tmdbId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistTmdbIdProgressGet(tmdbId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistTmdbIdProgressGet(tmdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets progress for all episodes up to (and including) the specified episode. 
     * @summary Set episode progress up to an episode (inclusive) for a show (by TMDB ID)
     * @param {number} tmdbId 
     * @param {ApiWatchlistTmdbIdProgressPutRequest} apiWatchlistTmdbIdProgressPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistTmdbIdProgressPut(tmdbId: number, apiWatchlistTmdbIdProgressPutRequest: ApiWatchlistTmdbIdProgressPutRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistTmdbIdProgressPut(tmdbId, apiWatchlistTmdbIdProgressPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List currently watching shows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistWatchingGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistWatchingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get detailed progress for a specific show (by internal show id)
     * @param {string} showId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiWatchlistWatchingShowIdGet(showId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiWatchlistWatchingShowIdGet(showId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search TMDB and add a show in one request
     * @param {WatchlistSearchAndAddRequest | null} watchlistSearchAndAddRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public watchlistSearchAndAdd(watchlistSearchAndAddRequest: WatchlistSearchAndAddRequest | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).watchlistSearchAndAdd(watchlistSearchAndAddRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiWatchlistGetStatusEnum = {
    Watchlist: 'watchlist',
    Watching: 'watching',
    Completed: 'completed',
    Dropped: 'dropped',
    All: 'all'
} as const;
export type ApiWatchlistGetStatusEnum = typeof ApiWatchlistGetStatusEnum[keyof typeof ApiWatchlistGetStatusEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetProfile: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGetProfile', 'id', id)
            const localVarPath = `/api/users/{id}/profile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users (admin/test)
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogin: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('usersLogin', 'loginRequest', loginRequest)
            const localVarPath = `/api/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSignup: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('usersSignup', 'signUpRequest', signUpRequest)
            const localVarPath = `/api/users/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user (partial)
         * @param {string} id 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: string, userUpdateRequest: UserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'userUpdateRequest' is not null or undefined
            assertParamExists('usersUpdate', 'userUpdateRequest', userUpdateRequest)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetProfile(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetProfile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List users (admin/test)
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Log in
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersLogin(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSignup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSignup(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user (partial)
         * @param {string} id 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: string, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, userUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetProfile(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.usersGetProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users (admin/test)
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UsersList200Response> {
            return localVarFp.usersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.usersLogin(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSignup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.usersSignup(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user (partial)
         * @param {string} id 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: string, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.usersUpdate(id, userUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get user profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetProfile(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGetProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users (admin/test)
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersLogin(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSignup(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSignup(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user (partial)
     * @param {string} id 
     * @param {UserUpdateRequest} userUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: string, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, userUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



